'use strict'
const reload = require('require-reload')(require);
const ErisUtils = reload('./../util/eris_utils.js');

function validateCommand(command) {
  let commandName = command.aliases[0];
  if (command.shortDescription && typeof command.shortDescription !== typeof '') {
    throw new Error('The shortDescription must be a string. It is not for ' + commandName);
  } else if (command.usageExample && typeof command.usageExample !== typeof '') {
    throw new Error('The usageExample must be a string. It is not for ' + commandName);
  }
}

function createTopLevelHelpTextForCommands(commands, helpCommandAlias) {
  if (commands.length === 0) {
    return;
  }
  let helpText = '```glsl\n';
  for (let command of commands) {
    helpText += createTopLevelHelpTextForCommand(command) + '\n';
  }
  helpText += '\n```\n\n';
  helpText += `Say ${helpCommandAlias} [command name] to see more help for a command.`
  return helpText;
}

function createTopLevelHelpTextForCommand(command) {
  validateCommand(command);
  let firstAlias = command.aliases[0];
  let otherAliases = command.aliases.slice(1);
  let helpText = firstAlias;
  if (otherAliases.length > 0) {
    helpText += ` (aliases: ${otherAliases.join(', ')})`;
  }
  if (command.shortDescription || command.usageExample) {
    helpText += '\n    # ';
  }
  if (command.shortDescription) {
    helpText += command.shortDescription + ' ';
  }
  if (command.usageExample) {
    helpText += 'Example: ' + command.usageExample;
  }

  return helpText;
}

function indexOfAliasInList(command, list) {
  for (let alias of command.aliases) {
    let index = list.indexOf(alias);
    if (index !== -1) {
      return index;
    }
  }
  return -1;
}

function compareCommandOrder(commandA, commandB, orderList) {
  return indexOfAliasInList(commandA, orderList) - indexOfAliasInList(commandB, orderList);
}

/**
* A command for reloading the command and message managers. This is a special command that the command manager has direct knowledge of.
*/
class Help {
  /**
  * @param {Array<Command>} otherCommands - The commands that should be considered to be included in the help.
  * @param {Array<String>} enabledSettingsForOtherCommands - An array of the enable setting name for each command.
  *   Must be parallel to the otherCommands array.
  * @param {Object} config - The monochrome config.
  */
  constructor(otherCommands, config) {
    this.commandAliases = config.autoGeneratedHelpCommandAliases;
    this.uniqueId = 'autoGeneratedHelp425654';
    this.commandsToGenerateHelpFor_ = otherCommands
      .filter(command => indexOfAliasInList(command, config.commandsToGenerateHelpFor) !== -1)
      .sort((a, b) => compareCommandOrder(a, b, config.commandsToGenerateHelpFor));
    this.requiredSettings = this.commandsToGenerateHelpFor_
      .map(command => command.getEnabledSettingFullyQualifiedUserFacingName())
      .filter(settingName => !!settingName);
    for (let command of this.commandsToGenerateHelpFor_) {
      validateCommand(command);
    }
    this.action = (bot, msg, suffix, settings) => this.execute_(bot, msg, suffix, settings);
  }

  execute_(bot, msg, suffix, settings) {
    let commandsToDisplayHelpFor = [];
    for (let command of this.commandsToGenerateHelpFor_) {
      let enabledSettingName = command.getEnabledSettingFullyQualifiedUserFacingName();
      if (enabledSettingName && !settings[enabledSettingName]) {
        continue;
      }
      commandsToDisplayHelpFor.push(command);
    }

    let helpText = createTopLevelHelpTextForCommands(commandsToDisplayHelpFor, this.commandAliases[0]);
    if (helpText) {
      return msg.channel.createMessage(helpText);
    } else {
      return 'No commands to show help for';
    }
  }
}

module.exports = Help;
